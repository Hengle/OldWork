
// SDParse.cpp - generated by the SLK parser generator 

#include "SDParse.h"

namespace DataScript {

static slk_size_t Parse[] = {

0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3
,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3
,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4
,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5
,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6
,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6
,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7
,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8
,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9
,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10
,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11
,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12
,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12
,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13
,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14
,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14
,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15
,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16
,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17
,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17
,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,18,18,18,18
,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,19,19
,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19
,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20
,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21
,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21
,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22
,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23
,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23
,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24
,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25
,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26
,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26
,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27
,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28
,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28
,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29
,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30
,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30
,30,30,30,30,31,31,31,31,31,31,31,31,31,31,31,31,31,32,31,32
,32,31,32,31,32,31,31,31,31,31,31,31,31,83,83,83,83,83,83,83
,83,83,83,83,83,83,83,83,83,82,83,82,83,82,83,83,83,83,83,83
,83,83,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,89,88,89
,88,89,88,89,89,89,89,89,89,89,89,91,91,91,91,91,91,91,91,91
,91,91,91,91,91,91,91,90,91,90,91,90,91,91,91,91,91,91,91,91
,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,93,92,93,92,93
,92,93,93,93,93,93,93,93,93,1,1,1,1,1,1,1,1,1,1,1
,1,1,1,0,1,1,36,1,37,1,1,1,1,1,1,1,1,1,85,85
,85,85,85,85,85,85,85,85,85,85,85,84,85,84,38,85,39,85,40,85
,85,85,85,85,85,85,85,81,81,81,81,81,81,81,81,81,81,81,81,81
,35,81,35,34,81,34,81,34,80,80,80,80,80,81,81,81,87,87,87,87
,87,87,87,87,87,87,87,87,87,86,87,86,0,87,0,87,33,33,33,33
,33,0,87,87,87,79,79,79,79,79,79,79,79,79,79,79,79,78,44,79
,0,42,79,43,79,0,41,41,41,41,41,79,79,79,77,77,77,77,77,77
,77,77,77,77,77,76,50,51,77,0,0,77,0,77,45,46,47,48,49,0
,77,77,77,75,75,75,75,75,75,75,75,75,75,74,0,0,0,75,0,0
,75,0,75,0,0,0,0,0,54,75,75,75,73,73,73,73,73,73,73,73
,73,72,55,0,0,55,73,55,0,73,0,73,0,0,55,55,55,0,73,73
,73,71,71,71,71,71,71,71,71,70,0,0,0,0,0,71,0,0,71,0
,71,0,0,0,59,59,58,71,71,71,69,69,69,69,69,69,69,68,59,0
,0,59,0,59,69,0,0,69,0,69,59,59,59,0,0,0,69,69,69,67
,67,67,67,67,67,66,0,0,0,0,0,0,0,67,0,0,67,0,67,65
,65,65,65,65,64,67,67,67,0,0,0,0,0,65,0,0,65,0,65,63
,63,63,63,62,0,65,65,65,0,0,0,0,0,63,0,0,63,0,63,61
,61,61,60,57,56,63,63,63,0,0,0,0,0,61,0,0,61,57,61,0
,57,0,57,0,0,61,61,61,0,57,57,57,53,0,0,53,0,53,0,0
,0,0,0,0,52,52,53
};

static slk_size_t Parse_row[] = {0

,987,1,30,59,88,117,146,175,204,233,262,291,320,349,378,407
,436,465,494,523,552,581,610,639,668,697,726,755,784,813,842,1073
,1045,991,1016,1103,1131,1118,1356,1186,1341,1242,1337,1317,1297,1277,1248,1219
,1190,1161,1132,1103,1045,871,1016,1074,900,929,958
,0};

static slk_size_t Conflict[] = {

0
};

static slk_size_t Conflict_row[] = {0


,0};

static slk_size_t Production[] = {0

,0,30,31,0,31,68,32,0,32,89,45,0,33,89,46,0,34,89,47
,0,35,89,48,0,36,89,49,0,37,89,50,0,38,89,51
,0,39,89,52,0,40,89,53,0,41,89,54,0,42,89,55
,0,43,89,56,0,44,89,57,0,45,69,46,0,46,70,47
,0,47,71,48,0,48,72,49,0,49,73,50,0,50,74,51
,0,51,75,52,0,52,76,53,0,53,77,54,0,54,78,55
,0,55,79,56,0,56,80,57,0,57,81,59,0,58,89,59
,0,59,60,94,0,60,82,0,60,96,62,95,0,61,84,83,97,66
,0,62,85,64,0,62,63,0,63,15,31,98,14,0,63,100,16,99
,0,64,86,18,31,101,17,0,64,87,20,31,103,19,0,64,88,65,21
,0,65,89,96,105,66,95,94,104,0,65,18,31,106,17,0,65,20,31,107,19
,0,65,15,31,108,14,0,66,90,22,0,66,109,23,0,66,110,24
,0,66,111,25,0,66,112,26,0,67,27,0,67,28,0,68,68,32,67
,0,68,0,69,69,33,91,90,1,0,69,0,70,70,34,93,90,2,34,92,90,2
,0,70,0,71,71,35,91,90,3,0,71,0,72,72,36,91,90,4
,0,72,0,73,73,37,91,90,5,0,73,0,74,74,38,91,90,6
,0,74,0,75,75,39,91,90,7,0,75,0,76,76,40,91,90,8
,0,76,0,77,77,41,91,90,9,0,77,0,78,78,42,91,90,10
,0,78,0,79,79,43,91,90,11,0,79,0,80,80,44,91,90,12
,0,80,0,81,81,58,91,90,13,0,81,0,82,82,96,61,95
,0,82,0,83,64,0,83,0,84,63,0,84,0,85,63,0,85
,0,86,64,102,0,86,0,87,64,102,0,87,0,88,64,102
,0,88
,0};

static slk_size_t Production_row[] = {0

,1,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60
,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,123
,128,134,138,141,147,152,159,166,171,180,186,192,198,202,206,210
,214,218,221,224,229,231,238,240,251,253,260,262,269,271,278,280
,287,289,296,298,305,307,314,316,323,325,332,334,341,343,350,352
,358,360,363,365,368,370,373,375,379,381,385,387,391
,0};

#define GET_CONDITIONAL_PRODUCTION( symbol )  0 
#define get_predicted_entry( a,b,c,d,e,f,g )  0 

#define START_SYMBOL 30
#define START_CONFLICT 94
#define START_ACTION 89
#define END_ACTION 113
#define TOTAL_CONFLICTS 0
#define PARSE_STACK_SIZE 512
#define SLK_PUSH(symbol,stack,top) if ( top > stack ) *--top = symbol
#define SLK_POP(top)   (*top ? *top++ : 0)

#define trace(self,a)              self.trace(a)
#define trace_depth(self,a,b)      self.trace_depth(a,b)
#define trace_production(self,a)   self.trace_production(a)
#define trace_action(self,a)       self.trace_action(a)
#define peek(self,a)             self.peek(a)
#define get(self)                self.get()
#define mismatch(self,a,b)      self.mismatch(a,b)
#define no_entry(self,a,b,c)    self.no_entry(a,b,c)
#define input_left(self)        self.input_left()
#define make_root(self,a)        self.make_root(a)
#define push_rhs_symbol(self,a)  self.push_rhs_symbol(a)
#define add_rhs(self)            self.add_rhs()
#define pop_current(self)        self.pop_current()
#define EXECUTE(action,symbol) action.execute(symbol-(START_ACTION-1))

int SDGetSymbolType ( slk_size_t symbol )
{
   int   symbol_type = NOT_A_SYMBOL;

   if ( symbol >= START_ACTION  &&  symbol < END_ACTION ) {
       symbol_type = ACTION_SYMBOL;
   } else if ( symbol >= START_SYMBOL ) {
       symbol_type = NONTERMINAL_SYMBOL;
   } else if ( symbol > 0 ) {
       symbol_type = TERMINAL_SYMBOL;
   }

   return  symbol_type;
}

int SDIsNonterminal ( slk_size_t symbol )
{
   return ( symbol >= START_SYMBOL  &&  symbol < START_ACTION );
}

int SDIsTerminal ( slk_size_t symbol )
{
   return ( symbol > 0  &&  symbol < START_SYMBOL );
}

int SDIsAction ( slk_size_t symbol )
{
   return ( symbol >= START_ACTION  &&  symbol < END_ACTION );
}

slk_size_t SDGetProduction ( slk_size_t   conflict_number,
                              SDToken   &tokens ) 
{
    slk_size_t  entry = 0;
    int         index, level;

    if ( conflict_number <= TOTAL_CONFLICTS ) {
        entry = conflict_number + (START_CONFLICT -1);
        level = 1;
        while ( entry >= START_CONFLICT ) {
            index = Conflict_row [entry - (START_CONFLICT -1)];
            index += peek ( tokens, level );
            entry = Conflict [ index ];
            ++level;
        }
    }

    return  entry;
}

void SDParse ( int         display,
                SDAction  &action, 
                SDToken   &tokens, 
                SDError   &error, 
                SDLog     &log, 
                // Tree    &tree,
                slk_size_t  start_symbol ) 
{
 register
 slk_size_t  *top, *production;
 slk_size_t   production_number, entry, symbol, token, new_token;
 int          index, level;
 slk_size_t   stack [ PARSE_STACK_SIZE ];

 top = stack + (PARSE_STACK_SIZE-1);
 *top = 0;
 if ( ! start_symbol ) {
     start_symbol = START_SYMBOL;
 }
 SLK_PUSH ( start_symbol, stack, top );
 //   root ( tree, start_symbol );
 token = get(tokens);
 new_token = token;
 if ( display ) {
     trace ( log, "\n\n\t\tPARSE DERIVATION\n\n" );
 }

 for ( symbol = SLK_POP ( top );  symbol;  ) {

     if ( symbol >= START_ACTION ) {
         if ( display ) {
             trace_action ( log, symbol );
         }
         EXECUTE ( action, symbol );

     } else if ( symbol >= START_SYMBOL ) {

         entry = 0;
         level = 1;
         production_number = GET_CONDITIONAL_PRODUCTION ( symbol );
         if ( production_number ) {
             entry = get_predicted_entry ( display, tokens, log,
                                           production_number, token,
                                           level, 1 );
         }
         if ( ! entry ) {
             index = Parse_row [symbol - (START_SYMBOL-1)];
             index += token;
             entry = Parse [ index ];
         }
         while ( entry >= START_CONFLICT ) {
             index = Conflict_row [entry - (START_CONFLICT -1)];
             index += peek (tokens, level);
             entry = Conflict [ index ];
             ++level;
         }
         if ( entry ) {
             production = &Production [ Production_row [entry] ];
             if ( *++production == symbol ) {
                 while ( *++production ) {
                     SLK_PUSH ( *production, stack, top );
                     //   rhs_symbol ( tree, *production );
                 }
                 //   hs (tree);
                 if ( display ) {
                     trace_production ( log, entry );
                 }
             } else {
                 new_token = no_entry ( error, symbol, token, level-1 );
             }
         } else {
             new_token = no_entry ( error, symbol, token, level-1 );
         }

     } else if ( symbol > 0 ) {
         if ( symbol == token ) {
             token = get(tokens);
             new_token = token;
         } else {
             new_token = mismatch ( error, symbol, token );
         }

     } else {
         trace ( log, "\n parser error: symbol value 0\n" );
     }

     if ( token != new_token ) {
         if ( new_token ) {
             token = new_token;
         }
         if ( token != END_OF_SLK_INPUT_ ) {
             continue;
         }
     }

     symbol = SLK_POP ( top );
     //   urrent (tree);
 }

 if ( token != END_OF_SLK_INPUT_ ) {
     input_left ( error );
 }

}



}
