using System;

namespace Dreaman.InfoService
{
	/// <summary>
	/// StateMachine 的摘要说明。
	/// 状态机是由多个松耦合的模块按用户（或开发人员）可定制的状态图展示的业务操作流程。
	/// 因为当前项目的几个子系统（OA已采用工作流平台）不涉及流程定制，这个想法没有实现。
	/// 用户可定制的状态图实际上可由三维表记录下来：
	///		对每个入口状态记录一个状态转换表即构成了要记录的表
	///		（判断，动作（调用模块），转换到的状态）
	///		判断可以采用JScript脚本定制，动作是一个模块的标识（参见模块管理器其它部分）
	///		转换到的状态简单用状态标识表示。
	///	流程执行：
	///		状态机执行需要实例化一个状态机，考虑到工作中的流程时间跨度可能很大，因此，
	///		状态机应该是可以序列化的（其实就是简单的记录其当前状态与某些上下文信息），
	///		通常将状态机实例序列化后存入数据库。
	/// </summary>
	/// <remarks>
	/// 这里的设计思想主要来自《Thinking in Patterns with JAVA》
	/// 为什么是状态机而不是协作类?
	/// 1、协作类考查类间相对紧密的耦合关系，而可定制对灵活性的要求很高，必须是松耦合
	/// 状态机的各状态间具有松耦合的特点；
	/// 2、一个流程虽然由各个模块组成，但本质上服务于一个特定的主题，如果把这个主题看
	/// 做对象，组成模块便是它的不同状态下的方法，而流程便是在各个状态间的转换；
	/// 3、流程存在较大时间跨度，在生命期内，到达特定结点时，系统必须允许重启，而重新
	/// 进入后流程应当从上次间断的结点继续，这表明流程要记忆当前结点，这便是状态，进
	/// 一步，状态必须可序列化。
	/// 附带的说点形而上的东西：
	/// 软件设计的范型通常是提供概念抽象，概念包括概念之内与概念之外，从概念外看，我们
	/// 对世界的分解粒度上升到概念提供的级别，这给了我们对世界建模的基本元素，就如同数
	/// 学中有了幂的概念后可以轻松理解2^64的涵义一样；从概念内看，概念又是存在内部结构
	/// 的，它可细分到更小的概念，这种内部结构是精化概念的关键，它确定了概念的内涵。系
	/// 统分析就是依据概念内涵确定系统里涉及的概念外延，这便是系统分解，分解后将每个概
	/// 念按内涵持续精化与调整，这便是设计。
	/// 总的说来，软件开发便是这种抽象与分解的艺术。而抽象与分解在多个层级交迭，最终形
	/// 自相似的螺旋结构（想象一下自相似的螺旋结构是什么样子？）
	/// </remarks>
	public class StateMachine
	{
		public StateMachine()
		{
			//
			// TODO: 在此处添加构造函数逻辑
			//
		}
	}
	/// <summary>
	/// 在状态机各状态间共享的参数信息
	/// </summary>
	public class Arguments
	{
	}
	/// <summary>
	/// 当前状态用来确定是否要发生转换的条件对象，它通过执行jscript脚本
	/// 来作出判断，符合条件时则执行相应的状态动作（调用某个模块）。
	/// </summary>
	public class Condition
	{
	}
	/// <summary>
	/// 状态的表示
	/// </summary>
	public class State
	{
	}
}
